use std::fmt;

pub const BIT64: [usize; 64] = [
    0b0000000000000000000000000000000000000000000000000000000000000001,
    0b0000000000000000000000000000000000000000000000000000000000000010,
    0b0000000000000000000000000000000000000000000000000000000000000100,
    0b0000000000000000000000000000000000000000000000000000000000001000,
    0b0000000000000000000000000000000000000000000000000000000000010000,
    0b0000000000000000000000000000000000000000000000000000000000100000,
    0b0000000000000000000000000000000000000000000000000000000001000000,
    0b0000000000000000000000000000000000000000000000000000000010000000,
    0b0000000000000000000000000000000000000000000000000000000100000000,
    0b0000000000000000000000000000000000000000000000000000001000000000,
    0b0000000000000000000000000000000000000000000000000000010000000000,
    0b0000000000000000000000000000000000000000000000000000100000000000,
    0b0000000000000000000000000000000000000000000000000001000000000000,
    0b0000000000000000000000000000000000000000000000000010000000000000,
    0b0000000000000000000000000000000000000000000000000100000000000000,
    0b0000000000000000000000000000000000000000000000001000000000000000,
    0b0000000000000000000000000000000000000000000000010000000000000000,
    0b0000000000000000000000000000000000000000000000100000000000000000,
    0b0000000000000000000000000000000000000000000001000000000000000000,
    0b0000000000000000000000000000000000000000000010000000000000000000,
    0b0000000000000000000000000000000000000000000100000000000000000000,
    0b0000000000000000000000000000000000000000001000000000000000000000,
    0b0000000000000000000000000000000000000000010000000000000000000000,
    0b0000000000000000000000000000000000000000100000000000000000000000,
    0b0000000000000000000000000000000000000001000000000000000000000000,
    0b0000000000000000000000000000000000000010000000000000000000000000,
    0b0000000000000000000000000000000000000100000000000000000000000000,
    0b0000000000000000000000000000000000001000000000000000000000000000,
    0b0000000000000000000000000000000000010000000000000000000000000000,
    0b0000000000000000000000000000000000100000000000000000000000000000,
    0b0000000000000000000000000000000001000000000000000000000000000000,
    0b0000000000000000000000000000000010000000000000000000000000000000,
    0b0000000000000000000000000000000100000000000000000000000000000000,
    0b0000000000000000000000000000001000000000000000000000000000000000,
    0b0000000000000000000000000000010000000000000000000000000000000000,
    0b0000000000000000000000000000100000000000000000000000000000000000,
    0b0000000000000000000000000001000000000000000000000000000000000000,
    0b0000000000000000000000000010000000000000000000000000000000000000,
    0b0000000000000000000000000100000000000000000000000000000000000000,
    0b0000000000000000000000001000000000000000000000000000000000000000,
    0b0000000000000000000000010000000000000000000000000000000000000000,
    0b0000000000000000000000100000000000000000000000000000000000000000,
    0b0000000000000000000001000000000000000000000000000000000000000000,
    0b0000000000000000000010000000000000000000000000000000000000000000,
    0b0000000000000000000100000000000000000000000000000000000000000000,
    0b0000000000000000001000000000000000000000000000000000000000000000,
    0b0000000000000000010000000000000000000000000000000000000000000000,
    0b0000000000000000100000000000000000000000000000000000000000000000,
    0b0000000000000001000000000000000000000000000000000000000000000000,
    0b0000000000000010000000000000000000000000000000000000000000000000,
    0b0000000000000100000000000000000000000000000000000000000000000000,
    0b0000000000001000000000000000000000000000000000000000000000000000,
    0b0000000000010000000000000000000000000000000000000000000000000000,
    0b0000000000100000000000000000000000000000000000000000000000000000,
    0b0000000001000000000000000000000000000000000000000000000000000000,
    0b0000000010000000000000000000000000000000000000000000000000000000,
    0b0000000100000000000000000000000000000000000000000000000000000000,
    0b0000001000000000000000000000000000000000000000000000000000000000,
    0b0000010000000000000000000000000000000000000000000000000000000000,
    0b0000100000000000000000000000000000000000000000000000000000000000,
    0b0001000000000000000000000000000000000000000000000000000000000000,
    0b0010000000000000000000000000000000000000000000000000000000000000,
    0b0100000000000000000000000000000000000000000000000000000000000000,
    0b1000000000000000000000000000000000000000000000000000000000000000,
];

pub struct BitSet {
    bits_list: [usize; 3],
}

impl BitSet {
    pub fn new() -> BitSet {
        BitSet { bits_list: [0; 3] }
    }

    pub fn add(&mut self, index: usize) {
        self.bits_list[index / 64] |= BIT64[index % 64]
    }
}

impl fmt::Display for BitSet {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "[0b{:064b}, 0b{:064b}, 0b{:064b}]",
            self.bits_list[0], self.bits_list[1], self.bits_list[2]
        )
    }
}

pub fn intersect2(
    list1: &(usize, usize, usize),
    list2: &(usize, usize, usize),
) -> (usize, usize, usize) {
    (list1.0 & list2.0, list1.1 & list2.1, list1.2 & list2.2)
}

pub fn intersect3(
    list1: &(usize, usize, usize),
    list2: &(usize, usize, usize),
    list3: &(usize, usize, usize),
) -> (usize, usize, usize) {
    (
        list1.0 & list2.0 & list3.0,
        list1.1 & list2.1 & list3.1,
        list1.2 & list2.2 & list3.2,
    )
}

pub struct BitSetTraverse {
    bits_list: (usize, usize, usize),
    bit_index: usize,
}

impl BitSetTraverse {
    pub fn new(bits_list: (usize, usize, usize)) -> BitSetTraverse {
        BitSetTraverse {
            bits_list: bits_list,
            bit_index: 0,
        }
    }
}

impl Iterator for BitSetTraverse {
    type Item = usize;
    fn next(&mut self) -> Option<Self::Item> {
        if self.bit_index < 64 {
            if self.bits_list.0 == 0 {
                self.bit_index = 64;
            } else {
                let mut tz = self.bits_list.0.trailing_zeros() as usize;
                let shift = tz + 1;
                if shift < 64 {
                    self.bits_list.0 >>= shift;
                }
                tz += self.bit_index;
                self.bit_index += shift;
                return Some(tz);
            }
        }

        if self.bit_index < 128 {
            if self.bits_list.1 == 0 {
                self.bit_index = 128;
            } else {
                let mut tz = self.bits_list.1.trailing_zeros() as usize;
                let shift = tz + 1;
                if shift < 64 {
                    self.bits_list.1 >>= shift;
                }
                tz += self.bit_index;
                self.bit_index += shift;
                return Some(tz);
            }
        }

        if self.bit_index < 192 && self.bits_list.2 != 0 {
            let mut tz = self.bits_list.2.trailing_zeros() as usize;
            let shift = tz + 1;
            if shift < 64 {
                self.bits_list.2 >>= shift;
            }
            tz += self.bit_index;
            self.bit_index += shift;
            return Some(tz);
        }

        None
    }
}
